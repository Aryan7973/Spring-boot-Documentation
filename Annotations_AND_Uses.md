# Different Annotation in Spring Boot

## @Transient
- It is applied on fields/methods which will tell the Hibernate to ignore this field.
- Fields/Methods having Trasnient are not stored in DB.
> Tells Hibernate this field exists in my Java Entity but NEVER touch the DB with it.  
> **Would I ever query/store this?? if no then Transient it.**
- Example :   
        - you use a fullName field in the entity and have a setter which concatenates.  
        - so setting this field and setter @Transient will not store this in DB as this is just for computation.

```
@Entity
@Table(name = "users")
@Getter @Setter
public class User{
        private String firstName;
        private String lastName;

        @Transient
        private String fullName;

        public String getFullName() {
                return firstName + " " + lastName;
        }
}
```
- Alternatives for Transient :

| Objective | Use this |
| ---- | --- |
| read only column in DB | @Column(insertable = false, updatable = false) + getter | 
| Just hiding from JSON serialize/deserialize | @JsonIgnore on getter | 
| hide from both JPA and JSON | @JsonIgnore + @Transient |


## @Builder
- Builders can ensure immutability patterns.
- Builders allow chained fluent calls.
- Prevents half created Objects.
- Safer with parameters with same types.
- Also Builder avoids constructor telescope problem.
> You can make fields final and still construct them using Builder With manual setters you cannot do this.
> The fields are temporarily stored until .build() is called once it is called the Object is then created.

- Example
```
// class definition

import lombok.*;
@Builder(toBuilder = "true")  //  if you remove toBuilder then you cannot update an already created a Object.
@Getter // Automated Getter generated by Lombok
@ToString // 
public class Student{
        private String name;
        private int age;
        final int rollNo;
}


// creating an object for the same.
Student newStudent = Student.Builder()
                .name("john")
                .age(19)
                .rollNo(201)
                .build();

// updating an object
Student updatedStudent = newStudent.Builder()
                .age(21)
                .build();

// another way when the method return type is Student.StudentBuilder

private Student.StudentBuilder prepareStudentBuilder(StudentRequest request){
        return Student.Builder()
                        .name(request.getName())
                        .age(request.getAge());
}

// in some other functions

Student newStudent = prepareStudentBuilder(req)
                        .rollNo(202)
                        .build();


```

## @Access
- AccessType

        
